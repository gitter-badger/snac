#!/usr/bin/env php
<?php

  /* 
   * Database Connector Test File
   * 
   * Usage: bulk_merge_ingest.php /data/merge 2> bmi.log
   * 
   * License: @author Tom Laudeman @license http://opensource.org/licenses/BSD-3-Clause BSD 3-Clause
   * @copyright 2015 the Rector and Visitors of the University of Virginia, and the Regents of the University
   * of California
   * 
   * Include the global autoloader generated by composer
   * Only need this if this code *is* the server (aka standalone, not part of the server)
   */
include "vendor/autoload.php";
include "src/snac/Config.php";

/* 
 * db connector test
 * @author Tom Laudeman
 * 
 * Tests the generic connection (part of the constructor) 
 */

global $argc, $argv;

$db = new \snac\server\database\DatabaseConnector();
$config = new snac\Config();

/* unbuffer stdin, stdout? Or something. */
stream_set_blocking(STDIN, 0);
stream_set_blocking(STDOUT, 0);

foo_main();
exit();


function foo_main () 
{
    global $argc, $argv, $config, $db;

    // U for Util.
    $dbu = new snac\server\database\DBUtil($db);

    list($appUserID, $role) = $dbu->getAppUserInfo('twl8n');
    printf("appUserID: %s role: %s\n", $appUserID, $role);
    
    // Works
    // printf("userid: %s\n", snac\Config::$userid);

    // Works also
    printf("userid: %s\n", $config::$userid);

    // load_vocab();

    $xx = 0;
    if ($argc>1)
    {
        
        $dbu->selectConstellation($argv[1], $argv[2], $appUserID);
    }
    else
    {
        list($version, $main_id) = $dbu->demoConstellation();
        $dbu->selectConstellation($version, $main_id, $appUserID);
    }

    if (0)
    {
        while ($short_file = readdir($dh))
        {
            if ($short_file == '.' or $short_file == '..')
            {
                continue;
            }
            $xx++;
            if ($xx > 10)
            {
                exit();
            }

            // Create a full path file name
            $file = "$argv[1]/$short_file";

            // Create new parser for this file and parse it
            $eparser = new \snac\util\EACCPFParser();
            $id = $eparser->parseFile($file);

        
            $unparsedTags = $eparser->getMissing();
            if (empty($unparsedTags))
            {
                $vh_info = $dbu->insertConstellation($id, $appUserID, $role, 'bulk ingest', 'bulk ingest of merged');
                check_vocabulary($id);
                // $msg = sprintf("File $file ok. vh_info: %s", var_export($vh_info, 1));
                $msg = sprintf("File $file ok.");
                quick_stderr($msg); // no terminal \n, the code will add that later
            }
            else
            {
                // For each unparsable tag and attribute in the parsed EAC-CPF, print it out

                // Print error messages to stderr, giving the user the option to io redirect to a separate log
                // file.
                foreach ($unparsedTags as $miss)
                {
                    quick_stderr($miss);
                    // fwrite($stderr,"  $miss\n");
                }
            }
        }
    }
}

/* 
 * entityType (person)
 * otherRecordIDs->type (MergedRecord)
 * maintenanceStatus (revised)
 * maintenanceEvents->eventType (revised)
 * maintenanceEvents->agentType (machine)
 * sources->type (simple)
 * legalStatuses (?)
 * constellationLanguage (English)
 * constellationLanguageCode (eng)
 * constellationScript ()
 * constellationScriptCode (Zyyy)
 * language
 * languageCode
 * script
 * scriptCode
 * nameEntries[]->language
 * nameEntries[]->scriptCode
 * occupations[]->term
 * occupations[]->vocabularySource (what is this?)
 * existDates[]->fromType
 * existDates[]->toType
 * # why isn't this "cpfRelations" if the one below is "resourceRelations"?
 * relations[]->targetEntityType (Person, same as entityType?)
 * relations[]->type (associatedWith)
 * relations[]->altType (simple)
 * relations[]->cpfRelationType (from anf)
 * resourceRelations[]->documentType (ArchivalResource, is this value always the same?)
 * resourceRelations[]->linkType (simple, is this always the same?)
 * resourceRelations[]->entryType
 * resourceRelations[]->role (referencedIn)
 * relations->targetEntityType
 * relations->type
 * functions[]->?
 * places->type (AssociatedPlace, is this always the same?)
 * subjects[]
 * nationality
 * gender
 * generalContext
 * structureOrGenealogy
 * mandate
 */


function check_vocabulary($id)
{
    // Maybe later we can write the code to check this constellation to see if it has any vocabulary not
    // already in the db.

    if (0)
    {
        // Set to true to var_export() a single constellation $id object and exit.  Perhaps not too useful
        // since those are all private vars. Someone is going to have to write getters for all of them.

        $cfile = fopen('constellation_var.txt', 'w');
        fwrite($cfile, var_export($id, 1));
        fclose($cfile); 
        exit();
    }
    return 1;
}

// None too efficient since it opens and closes the stream constantly.
function quick_stderr ($message)
{
    $stderr = fopen('php://stderr', 'w');
    fwrite($stderr,"  $message\n");
    fclose($stderr); 
}

function load_vocab()
{
    global $db;
    $qq = 'check_vocab';
    $db->prepare($qq, 'select * from vocabulary');
    $res = $db->execute($qq, array());
    print "Execute done\n";
    
    $all_vocab = array();
    while ($row = $db->fetchrow($res))
    {
        $key = $row['type'] . '::' . $row['value'];
        // print "key: $key\n";
        // Save a $row reference in $all_vocab
        $all_vocab[$key] = $row;
    }
    printf("Vocabulary loaded. %s rows\n", count($all_vocab));
    // var_export($all_vocab);
    // Hmm. json_encode doesn't work on $all_vocab. Nothing prints. Curious.
    // print json_encode($all_vocab, JSON_PRETTY_PRINT) . "\n";
}

