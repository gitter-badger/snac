#!/usr/bin/env php
<?php
/**
 * Refresh the Elatic Search Indices
 *
 * This script is more "dirty" to be efficient in rebuilding the Elastic Search index.  It queries
 * the postgres database directly to get required information to build the elastic search indices.
 *
 * It fills two indices by default: the base search index for UI interaction and the all names index
 * for identity reconciliation.
 *
 * @author Robbie Hott
 * @license http://opensource.org/licenses/BSD-3-Clause BSD 3-Clause
 * @copyright 2015 the Rector and Visitors of the University of Virginia, and
 *            the Regents of the University of California
 */
// Include the global autoloader generated by composer
include "../vendor/autoload.php";

use \Monolog\Logger;
use \Monolog\Handler\StreamHandler;

// Set up the global log stream
$log = new StreamHandler(\snac\Config::$LOG_DIR . \snac\Config::$SERVER_LOGFILE, Logger::DEBUG);

// SNAC Postgres DB Connector
$db = new \snac\server\database\DatabaseConnector();

$primaryCount = 0;
$secondaryCount = 0;
$primaryStart = false;
$secondaryStart = false;
$primaryBody = array();
$secondaryBody = array();

$rels = array();

$lookup = [
    "relation_type" => []
];

echo "Querying the vocabulary from the database.\n";

$result = $db->query("select * from vocabulary where type = 'relation_type';", array());
while($row = $db->fetchrow($result))
{
    $lookup["relation_type"][$row["id"]] = [
        "uri" => $row["uri"],
        "value" => $row["value"]
    ];
}


echo "Querying the relations from the database.\n";

$allRel = $db->query("select r.id, r.version, r.ic_id, r.related_id, r.related_ark, r.arcrole from
                related_identity r,
                (select distinct id, max(version) as version from related_identity group by id) a
                where a.id = r.id and a.version = r.version and not r.is_deleted", array());
while($row = $db->fetchrow($allRel))
{
    $arcrole = null;
    if (isset($lookup["relation_type"][$row["arcrole"]]))
        $arcrole = $lookup["relation_type"][$row["arcrole"]]["value"];

    $rels[$row["id"]] = [
        "id" => $row["id"],
        "version" => $row["version"],
        "source" => $row["ic_id"],
        "target" => $row["related_id"], 
        "target_ark" => $row["related_ark"],
        "arcrole" => $arcrole
    ];
    if (empty($rels[$row["id"]])) {
        print_r($row);
        die("Something went wrong");
    }
        
}

/*
echo "Querying the resource relation degrees from the database.\n";

$allRelCount = $db->query("select a.ic_id, count(*) as degree from
            (select r.id, r.ic_id from
                related_resource r,
                (select distinct id, max(version) as version from related_resource group by id) a
                where a.id = r.id and a.version = r.version and not r.is_deleted) a
                group by ic_id", array());
while($c = $db->fetchrow($allRelCount))
{
    $counts[$c["ic_id"]]["resources"] = $c["degree"];
}
 */

$previousICID = -1;


echo "Querying the names from the database.\n";

$allNames = $db->query("select one.ic_id, one.version, one.ark_id, two.id as name_id, two.original, two.preference_score, one.entity_type from
    (select
        aa.is_deleted,aa.id,aa.version, aa.ic_id, aa.original, aa.preference_score
    from
        name as aa,
        (select name.id,max(name.version) as version from name
            left join (select v.id as ic_id, v.version, nrd.ark_id
                    from version_history v
                    left join (select bb.id, max(bb.version) as version from
                    (select id, version from version_history where status in ('published', 'deleted')) bb
                    group by id order by id asc) mv
                    on v.id = mv.id and v.version = mv.version
                    left join nrd on v.id = nrd.ic_id
                    where
                    v.status = 'published'
                    order by v.id asc, v.version desc) vh
                on name.version<=vh.version and
                name.ic_id=vh.ic_id
            group by name.id) as bb
    where
        aa.id = bb.id and
        not aa.is_deleted and
        aa.version = bb.version
    order by ic_id asc, preference_score desc, id asc) two,
    (select v.id as ic_id, v.version, n.ark_id, etv.value as entity_type
    from
        version_history v,
        (select bb.id, max(bb.version) as version from
            (select id, version from version_history where status in ('published', 'deleted')) bb
            group by id order by id asc) mv,
        vocabulary etv,
        nrd n
    where
        v.id = mv.id and
        v.version = mv.version and
        v.status = 'published' and
        v.id = n.ic_id and
        n.ark_id is not null and
        n.entity_type = etv.id) one
where
    two.ic_id = one.ic_id
order by
    one.ic_id asc, two.preference_score desc, two.id asc;", array());


$nodes = array();
echo "This may take a while...\n";
while($name = $db->fetchrow($allNames))
{

    if ($previousICID != $name["ic_id"]) {
        $nodes[$name["ic_id"]] = [
            "id" => $name["ic_id"],
            "ark" => $name["ark_id"],
            "version" => $name["version"],
            "entity_type" => $name["entity_type"],
            "name" => $name["original"]
        ];
    }
    $previousICID = $name["ic_id"];
}

$full = [
    "nodes" => $nodes,
    "edges" => $rels
];
echo json_encode($full, JSON_PRETTY_PRINT);

