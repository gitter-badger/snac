#!/usr/bin/env php
<?php
/**
 * Refresh the Elatic Search Indices
 *
 * This script is more "dirty" to be efficient in rebuilding the Elastic Search index.  It queries
 * the postgres database directly to get required information to build the elastic search indices.
 *
 * It fills two indices by default: the base search index for UI interaction and the all names index
 * for identity reconciliation.
 *
 * @author Robbie Hott
 * @license http://opensource.org/licenses/BSD-3-Clause BSD 3-Clause
 * @copyright 2015 the Rector and Visitors of the University of Virginia, and
 *            the Regents of the University of California
 */
// Include the global autoloader generated by composer
include "../vendor/autoload.php";

use \Monolog\Logger;
use \Monolog\Handler\StreamHandler;

// Set up the global log stream
$log = new StreamHandler(\snac\Config::$LOG_DIR . \snac\Config::$SERVER_LOGFILE, Logger::DEBUG);

// SNAC Postgres DB Connector
$db = new \snac\server\database\DatabaseConnector();

// ElasticSearch Handler
$eSearch = null;

$primaryCount = 0;
$secondaryCount = 0;
$primaryStart = false;
$secondaryStart = false;
$primaryBody = array();
$secondaryBody = array();
if (\snac\Config::$USE_ELASTIC_SEARCH) {
    $eSearch = Elasticsearch\ClientBuilder::create()
        ->setHosts([\snac\Config::$ELASTIC_SEARCH_URI])
        ->setRetries(0)
        ->build();

    echo "Trying to delete the Elastic Search Index: " . \snac\Config::$ELASTIC_SEARCH_BASE_INDEX . "\n";
    try {
        $params = array("index" => \snac\Config::$ELASTIC_SEARCH_BASE_INDEX);
        $response = $eSearch->indices()->delete($params);
        echo "   - deleted search index\n";
    } catch (\Exception $e) {
        echo "   - could not delete search index. It did not exist.\n";
    }

    $previousICID = -1;

    echo "Querying the names from the database.\n";

    $allNames = $db->query("select one.ic_id, one.version, one.ark_id, two.id as name_id, two.original, two.preference_score from
        (select
        	aa.is_deleted,aa.id,aa.version, aa.ic_id, aa.original, aa.preference_score
        from
        	name as aa,
        	(select name.id,max(name.version) as version from name
        		left join (select v.id as ic_id, v.version, nrd.ark_id
        				from version_history v
        				left join (select bb.id, max(bb.version) as version from
        				(select id, version from version_history where status in ('published', 'deleted')) bb
        				group by id order by id asc) mv
        				on v.id = mv.id and v.version = mv.version
        				left join nrd on v.id = nrd.ic_id
        				where
        				v.status = 'published'
        				order by v.id asc, v.version desc) vh
        			on name.version<=vh.version and
        			name.ic_id=vh.ic_id
        		group by name.id) as bb
        where
        	aa.id = bb.id and
        	not aa.is_deleted and
        	aa.version = bb.version
        order by ic_id asc, preference_score desc, id asc) two,
        (select v.id as ic_id, v.version, n.ark_id
        from
        	version_history v,
        	(select bb.id, max(bb.version) as version from
        		(select id, version from version_history where status in ('published', 'deleted')) bb
        		group by id order by id asc) mv,
        	nrd n
        where
        	v.id = mv.id and
        	v.version = mv.version and
        	v.status = 'published' and
        	v.id = n.ic_id
        order by v.id asc, v.version desc) one
        where
        	two.ic_id = one.ic_id
        order by
        	one.ic_id asc, two.preference_score desc, two.id asc;", array());


    echo "Updating the Elastic Search indices. This may take a while...\n";
    while($name = $db->fetchrow($allNames))
    {
        // The data is ordered by ic_id and then preference score.  We will currently say the preferred name
        // is the one with the highest preference score for each ic_id.  So, if we haven't ever seen this ic_id
        // before, this is the preferred name entry for this ic.
        if ($previousICID != $name["ic_id"]) {
            indexMain($name["original"], $name["ark_id"], $name["ic_id"]);
        }
        indexSecondary($name["original"], $name["ark_id"], $name["ic_id"], $name["name_id"]);
        $previousICID = $name["ic_id"];
    }

    echo "Cleaning up last bulk updates\n";
    bulkUpdate($primaryBody, $primaryCount);
    bulkUpdate($secondaryBody, $secondaryCount);


    echo "Done\n";
} else {
    echo "This version of SNAC does not currently use Elastic Search.  Please check your configuration file.\n";
}

function indexMain($nameText, $ark, $icid) {
    global $eSearch, $primaryBody, $primaryStart, $primaryCount;
    if ($eSearch != null) {
        // do one first to get the index going
        if (!$primaryStart) {
            $params = [
                    'index' => \snac\Config::$ELASTIC_SEARCH_BASE_INDEX,
                    'type' => \snac\Config::$ELASTIC_SEARCH_BASE_TYPE,
                    'id' => $icid,
                    'body' => [
                            'nameEntry' => $nameText,
                            'arkID' => $ark,
                            'id' => $icid,
                            'timestamp' => date("c")
                    ]
            ];

            $eSearch->index($params);
            $primaryStart = true;
        } else {
            if ($primaryCount == 100000) {
                echo "  Running Primary bulk update\n";
                bulkUpdate($primaryBody, $primaryCount);
            }
            $primaryBody['body'][] = [
                'index' => [
                    '_index' => \snac\Config::$ELASTIC_SEARCH_BASE_INDEX,
                    '_type' => \snac\Config::$ELASTIC_SEARCH_BASE_TYPE,
                    '_id' => $icid
                ]
            ];
            $primaryBody['body'][] = [
                'nameEntry' => $nameText,
                'arkID' => $ark,
                'id' => $icid,
                'timestamp' => date("c")
            ];
            $primaryCount++;
        }
    }
}


function indexSecondary($nameText, $ark, $icid, $nameid) {
    global $eSearch, $secondaryBody, $secondaryStart, $secondaryCount;
    if ($eSearch != null) {
        // do one first to get the index going
        if (!$secondaryStart) {
            $params = [
                    'index' => \snac\Config::$ELASTIC_SEARCH_BASE_INDEX,
                    'type' => \snac\Config::$ELASTIC_SEARCH_ALL_TYPE,
                    'id' => $nameid,
                    'body' => [
                            'nameEntry' => $nameText,
                            'arkID' => $ark,
                            'id' => $icid,
                            'name_id' => $nameid,
                            'timestamp' => date("c")
                    ]
            ];

            $eSearch->index($params);
            $secondaryStart = true;
        } else {
            if ($secondaryCount == 100000) {
                echo "  Running Secondary bulk update\n";
                bulkUpdate($secondaryBody, $secondaryCount);
            }
            // elasticsearch api = array with "index" => array(information), followed by array of data, then repeated
            $secondaryBody['body'][] = [
                'index' => [
                    '_index' => \snac\Config::$ELASTIC_SEARCH_BASE_INDEX,
                    '_type' => \snac\Config::$ELASTIC_SEARCH_ALL_TYPE,
                    '_id' => $nameid
                ]
            ];
            $secondaryBody['body'][] = [
                'nameEntry' => $nameText,
                'arkID' => $ark,
                'id' => $icid,
                'name_id' => $nameid,
                'timestamp' => date("c")
            ];
            $secondaryCount++;
        }
    }
}

function bulkUpdate(&$body, &$count) {
    global $eSearch;
    if ($eSearch != null) {
        $count = 0;

        $responses = $eSearch->bulk($body);

        // erase the old bulk request
        $body = array();

        // unset the bulk response when you are done to save memory
        unset($responses);
    }
}
