#!/usr/bin/env php
<?php
/**
 * Reads EAC-CPF XML filenames from standard input, then parses them
 * and returns SQL insert statements for all the controlled vocabulary
 * terms.
 * 
 * @author Robbie Hott
 * @license http://opensource.org/licenses/BSD-3-Clause BSD 3-Clause
 * @copyright 2015 the Rector and Visitors of the University of Virginia, and
 *            the Regents of the University of California
 */
// Include the global autoloader generated by composer
include "../vendor/autoload.php";

/**
 * Test vocabulary.  This class definition allows the parser
 * to work without needing a working database.  Instead of
 * querying the database for all the controlled vocabulary
 * to get correct IDs, this vocabulary simply fills in Term
 * objects with the data available in the EAC-CPF itself and
 * ignores database IDs.
 * 
 * @author Robbie Hott
 *
 */
class TestVocabulary implements \snac\util\Vocabulary {

    /**
     * {@inheritDoc}
     * @see \snac\util\Vocabulary::getTermByValue()
     */
    public function getTermByValue($value, $type) {
        $term = new \snac\data\Term();
        $term->setTerm($value);
        $term->setURI($type);
        return $term;
    }

    /**
     * {@inheritDoc}
     * @see \snac\util\Vocabulary::getTermByID()
     */
    public function getTermByID($id, $type) {
        $term = new \snac\data\Term();
        $term->setID($id);
        $term->setURI($type);
        return $term;
    }
}


// Set STDIN to not block, so that we can give an error message if needed
stream_set_blocking(STDIN, 0);

// Did we parse a file?
$parsedFile = false;

// Read through the lines of STDIN
while ($filename = trim(fgets(STDIN))) {
    $parsedFile = true;

    // Print out a message stating that this file is being parsed
    echo "Parsing: $filename\n";

    // Create new parser for this file and parse it
    $e = new \snac\util\EACCPFParser();
    $e->setVocabulary(new TestVocabulary());
    $constellation = $e->parseFile($filename);

    // For each unparsable tag and attribute in the parsed EAC-CPF, print it out
    foreach ($e->getMissing() as $miss) {
        echo "  " .$miss. "\n"; 
    }

    foreach ($constellation->getPlaces() as $place) {
        if ($place->getGeoTerm() != null) {
            $geo = $place->getGeoTerm();
            fwrite(STDERR, "INSERT INTO 'geoplace' (name, latitude, longitude, administrative_code, country_code, geoname_id) values ("
                                ."'".$geo->getName()."',"
                                ."'".$geo->getLatitude()."',"
                                ."'".$geo->getLongitude()."',"
                                ."'".$geo->getAdministrationCode()."',"
                                ."'".$geo->getCountryCode()."',"
                                ."'".$geo->getURI()."');\n");
        }

    }
}

// If no file was parsed, then print the output that something went wrong
if ($parsedFile == false) {
    echo "No files given on STDIN\n\n"
        . "Reads a list of filenames from standard input (one per line),\n"
        . "then parses the files into Identity Constellations and prints\n"
        . "to standard output the SQL insert statements for controlled\n"
        . "vocabulary places in those Constellations.\n\n"
        . "Sample usage: find /snac/data/ -name \"*.xml\" | php get_place_vocab.php\n\n";

}

