#!/usr/bin/env php
<?php
/**
 * Refresh the Elatic Search Indices
 *
 * This script is more "dirty" to be efficient in rebuilding the Elastic Search index.  It queries
 * the postgres database directly to get required information to build the elastic search indices.
 *
 * It fills two indices by default: the base search index for UI interaction and the all names index
 * for identity reconciliation.
 *
 * @author Robbie Hott
 * @license http://opensource.org/licenses/BSD-3-Clause BSD 3-Clause
 * @copyright 2015 the Rector and Visitors of the University of Virginia, and
 *            the Regents of the University of California
 */
// Include the global autoloader generated by composer
include "../vendor/autoload.php";

use \Monolog\Logger;
use \Monolog\Handler\StreamHandler;

// Set up the global log stream
$log = new StreamHandler(\snac\Config::$LOG_DIR . \snac\Config::$SERVER_LOGFILE, Logger::DEBUG);

// SNAC Postgres DB Connector
$db = new \snac\server\database\DatabaseConnector();

$primaryCount = 0;
$secondaryCount = 0;
$primaryStart = false;
$secondaryStart = false;
$primaryBody = array();
$secondaryBody = array();

$rels = array();

$lookup = [
    "relation_type" => []
];

echo "Querying the vocabulary from the database.\n";

$result = $db->query("select * from vocabulary where type = 'relation_type';", array());
while($row = $db->fetchrow($result))
{
    $lookup["relation_type"][$row["id"]] = [
        "uri" => $row["uri"],
        "value" => $row["value"]
    ];
}
$result = $db->query("select * from vocabulary where type = 'date_type';", array());
while($row = $db->fetchrow($result))
{
    $lookup["date_type"][$row["id"]] = [
        "uri" => $row["uri"],
        "value" => $row["value"]
    ];
}


echo "Querying the relations from the database.\n";

$allRel = $db->query("select r.id, r.ic_id, r.related_id, r.related_ark, r.arcrole from
                related_identity r,
                (select distinct id, max(version) as version from related_identity group by id) a
                where a.id = r.id and a.version = r.version and not r.is_deleted", array());
while($row = $db->fetchrow($allRel))
{
    $arcrole = null;
    if (isset($lookup["relation_type"][$row["arcrole"]]))
        $arcrole = $lookup["relation_type"][$row["arcrole"]]["value"];

    $rels[$row["id"]] = [
        "source" => $row["ic_id"],
        "target" => $row["related_id"], 
        "target_ark" => $row["related_ark"],
        "arcrole" => $arcrole
    ];
    if (empty($rels[$row["id"]])) {
        print_r($row);
        die("Something went wrong");
    }
        
}

$dates = array();
echo "Querying the dates from the database.\n";

$allD = $db->query("select d.fk_id, d.from_date, d.from_type, d.to_date, d.to_type from
                date_range d,
                (select distinct id, max(version) as version from date_range group by id) a
                where a.id = d.id and a.version = d.version and not d.is_deleted", array());
while($row = $db->fetchrow($allD))
{
    if (!isset($row["from_date"]) || $row["from_date"] == null || $row["from_date"] == "" ||
        !isset($row["to_date"]) || $row["to_date"] == null || $row["to_date"] == "" ||
        !isset($row["from_type"]) || !isset($lookup["date_type"][$row["from_type"]]) ||
        !isset($row["to_type"]) || !isset($lookup["date_type"][$row["to_type"]]) ||
        $lookup["date_type"][$row["from_type"]]["value"] != "Birth" ||
        $lookup["date_type"][$row["to_type"]]["value"] != "Death")
        continue;

    $dates[$row["fk_id"]] = [
        "begin" => $row["from_date"],
        "end" => $row["to_date"]
    ];
        
}
/*
echo "Querying the resource relation degrees from the database.\n";

$allRelCount = $db->query("select a.ic_id, count(*) as degree from
            (select r.id, r.ic_id from
                related_resource r,
                (select distinct id, max(version) as version from related_resource group by id) a
                where a.id = r.id and a.version = r.version and not r.is_deleted) a
                group by ic_id", array());
while($c = $db->fetchrow($allRelCount))
{
    $counts[$c["ic_id"]]["resources"] = $c["degree"];
}
 */

$previousICID = -1;


echo "Querying the names from the database.\n";

$allNames = $db->query("select one.ic_id, one.version, one.ark_id, two.id as name_id, two.original, two.preference_score, one.entity_type from
    (select
        aa.is_deleted,aa.id,aa.version, aa.ic_id, aa.original, aa.preference_score
    from
        name as aa,
        (select name.id,max(name.version) as version from name
            left join (select v.id as ic_id, v.version, nrd.ark_id
                    from version_history v
                    left join (select bb.id, max(bb.version) as version from
                    (select id, version from version_history where status in ('published', 'deleted')) bb
                    group by id order by id asc) mv
                    on v.id = mv.id and v.version = mv.version
                    left join nrd on v.id = nrd.ic_id
                    where
                    v.status = 'published'
                    order by v.id asc, v.version desc) vh
                on name.version<=vh.version and
                name.ic_id=vh.ic_id
            group by name.id) as bb
    where
        aa.id = bb.id and
        not aa.is_deleted and
        aa.version = bb.version
    order by ic_id asc, preference_score desc, id asc) two,
    (select v.id as ic_id, v.version, n.ark_id, etv.value as entity_type
    from
        version_history v,
        (select bb.id, max(bb.version) as version from
            (select id, version from version_history where status in ('published', 'deleted')) bb
            group by id order by id asc) mv,
        vocabulary etv,
        nrd n
    where
        v.id = mv.id and
        v.version = mv.version and
        v.status = 'published' and
        v.id = n.ic_id and
        n.ark_id is not null and
        n.entity_type = etv.id) one
where
    two.ic_id = one.ic_id
order by
    one.ic_id asc, two.preference_score desc, two.id asc;", array());


$nodes = array();
echo "Updating the Elastic Search indices. This may take a while...\n";
while($name = $db->fetchrow($allNames))
{
    // The data is ordered by ic_id and then preference score.  We will currently say the preferred name
    // is the one with the highest preference score for each ic_id.  So, if we haven't ever seen this ic_id
    // before, this is the preferred name entry for this ic.

    if ($previousICID != $name["ic_id"]) {
        $node = [
            "id" => $name["ic_id"],
            "ark" => $name["ark_id"],
            "version" => $name["version"],
            "entity_type" => $name["entity_type"],
            "name" => $name["original"]
        ];
        if (isset($dates[$name["ic_id"]])) {
            $node["begin"] = $dates[$name["ic_id"]]["begin"];
            $node["end"] = $dates[$name["ic_id"]]["end"];
            $nodes[$name["ic_id"]] = $node;
        }
    }
    $previousICID = $name["ic_id"];
}

$edges = array();
foreach ($rels as $id => &$edge) {
    if (isset($nodes[$edge["source"]]) && isset($nodes[$edge["target"]])) {
        $begin = $nodes[$edge["source"]]["begin"];
        if ($nodes[$edge["source"]]["begin"] < $nodes[$edge["target"]]["begin"])
            $begin = $nodes[$edge["target"]]["begin"];
        $end = $nodes[$edge["source"]]["end"];
        if ($nodes[$edge["source"]]["end"] > $nodes[$edge["target"]]["end"])
            $end = $nodes[$edge["target"]]["end"];

        if ($begin <= $end) {
            $edge["id"] = $id;
            $edge["begin"] = $begin;
            $edge["end"] = $end;
            array_push($edges, $edge);
        }
    }
}

$realNodes = array();
foreach ($nodes as &$node)
    array_push($realNodes, $node);

$full = [
    "nodes" => $realNodes,
    "edges" => $edges
];
echo json_encode($full, JSON_PRETTY_PRINT);

